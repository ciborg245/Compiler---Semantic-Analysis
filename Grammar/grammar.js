// Generated automatically by nearley
// http://github.com/Hardmath123/nearley
(function () {
function id(x) {return x[0]; }


const moo = require('moo');

let lexer = moo.compile({
	keyword: ['class', 'struct', 'true', 'false', 'void', 'if', 'else', 'while', 'return', 'int', 'char', 'boolean'],
	space: {match: /\s+/, lineBreaks: true},
	char: /'[a-zA-Z]'/,
	id:  /[a-zA-Z][a-zA-Z0-9]*/,
    string: /"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*"/,
    '{': '{',
    '}': '}',
    '[': '[',
    ']': ']',
    '(': '(',
    ')': ')',
    ',': ',',
    ':': ':',
    ';': ';',
    '+': '+',
    '-': '-',
    '*': '*',
    '%': '%',
    '/': '/',
    '==': '==',
    '=': '=',
    '&&': '&&',
    '||': '||',
    '<=': '<=',
    '>=': '>=',
    '>': '>',
    '<': '<',
    '!=': '!=',
    '\'': '\'',
    'true': 'true',
    'false': 'false',
    '!': '!',
    '.': '.',
	num: /-?(?:[0-9]|[1-9][0-9]+)(?:\.[0-9]+)?(?:[eE][-+]?[0-9]+)?\b/,
})

lexer.next = (next => () => {
    let tok;
    while ((tok = next.call(lexer)) && tok.type === "space") {}
    return tok;
})(lexer.next);

var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "program$ebnf$1", "symbols": []},
    {"name": "program$ebnf$1", "symbols": ["program$ebnf$1", "declaration"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "program", "symbols": [{"literal":"class"}, (lexer.has("id") ? {type: "id"} : id), {"literal":"{"}, "program$ebnf$1", {"literal":"}"}]},
    {"name": "declaration", "symbols": ["structDeclaration"]},
    {"name": "declaration", "symbols": ["varDeclaration"]},
    {"name": "declaration", "symbols": ["methodDeclaration"]},
    {"name": "varDeclaration", "symbols": ["varType", (lexer.has("id") ? {type: "id"} : id), {"literal":";"}]},
    {"name": "varDeclaration", "symbols": ["varType", (lexer.has("id") ? {type: "id"} : id), {"literal":"["}, (lexer.has("num") ? {type: "num"} : num), {"literal":"]"}, {"literal":";"}]},
    {"name": "structDeclaration$ebnf$1", "symbols": []},
    {"name": "structDeclaration$ebnf$1", "symbols": ["structDeclaration$ebnf$1", "varDeclaration"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "structDeclaration", "symbols": [{"literal":"struct"}, (lexer.has("id") ? {type: "id"} : id), {"literal":"{"}, "structDeclaration$ebnf$1", {"literal":"}"}]},
    {"name": "varType", "symbols": [{"literal":"int"}]},
    {"name": "varType", "symbols": [{"literal":"char"}]},
    {"name": "varType", "symbols": [{"literal":"boolean"}]},
    {"name": "varType", "symbols": [{"literal":"struct"}, (lexer.has("id") ? {type: "id"} : id)]},
    {"name": "varType", "symbols": ["structDeclaration"]},
    {"name": "varType", "symbols": [{"literal":"void"}]},
    {"name": "methodDeclaration$ebnf$1$subexpression$1$ebnf$1", "symbols": []},
    {"name": "methodDeclaration$ebnf$1$subexpression$1$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "parameter"]},
    {"name": "methodDeclaration$ebnf$1$subexpression$1$ebnf$1", "symbols": ["methodDeclaration$ebnf$1$subexpression$1$ebnf$1", "methodDeclaration$ebnf$1$subexpression$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "methodDeclaration$ebnf$1$subexpression$1", "symbols": ["parameter", "methodDeclaration$ebnf$1$subexpression$1$ebnf$1"]},
    {"name": "methodDeclaration$ebnf$1", "symbols": ["methodDeclaration$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "methodDeclaration$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "methodDeclaration", "symbols": ["methodType", (lexer.has("id") ? {type: "id"} : id), {"literal":"("}, "methodDeclaration$ebnf$1", {"literal":")"}, "block"]},
    {"name": "methodType", "symbols": [{"literal":"int"}]},
    {"name": "methodType", "symbols": [{"literal":"char"}]},
    {"name": "methodType", "symbols": [{"literal":"boolean"}]},
    {"name": "methodType", "symbols": [{"literal":"void"}]},
    {"name": "parameter", "symbols": ["parameterType", (lexer.has("id") ? {type: "id"} : id)]},
    {"name": "parameter", "symbols": ["parameterType", (lexer.has("id") ? {type: "id"} : id), {"literal":"["}, {"literal":"]"}]},
    {"name": "parameterType", "symbols": [{"literal":"int"}]},
    {"name": "parameterType", "symbols": [{"literal":"char"}]},
    {"name": "parameterType", "symbols": [{"literal":"boolean"}]},
    {"name": "block$ebnf$1", "symbols": []},
    {"name": "block$ebnf$1", "symbols": ["block$ebnf$1", "varDeclaration"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "block$ebnf$2", "symbols": []},
    {"name": "block$ebnf$2", "symbols": ["block$ebnf$2", "statement"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "block", "symbols": [{"literal":"{"}, "block$ebnf$1", "block$ebnf$2", {"literal":"}"}]},
    {"name": "statement$ebnf$1$subexpression$1", "symbols": [{"literal":"else"}, "block"]},
    {"name": "statement$ebnf$1", "symbols": ["statement$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "statement$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "statement", "symbols": [{"literal":"if"}, {"literal":"("}, "expression", {"literal":")"}, "block", "statement$ebnf$1"]},
    {"name": "statement", "symbols": [{"literal":"while"}, {"literal":"("}, "expression", {"literal":")"}, "block"]},
    {"name": "statement$ebnf$2", "symbols": ["expression"], "postprocess": id},
    {"name": "statement$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "statement", "symbols": [{"literal":"return"}, "statement$ebnf$2", {"literal":";"}]},
    {"name": "statement", "symbols": ["methodCall", {"literal":";"}]},
    {"name": "statement", "symbols": ["block"]},
    {"name": "statement", "symbols": ["location", {"literal":"="}, "expression", {"literal":";"}]},
    {"name": "statement$ebnf$3", "symbols": ["expression"], "postprocess": id},
    {"name": "statement$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "statement", "symbols": ["statement$ebnf$3", {"literal":";"}]},
    {"name": "location$subexpression$1", "symbols": [(lexer.has("id") ? {type: "id"} : id)]},
    {"name": "location$subexpression$1", "symbols": [(lexer.has("id") ? {type: "id"} : id), {"literal":"["}, "expression", {"literal":"]"}]},
    {"name": "location$ebnf$1$subexpression$1", "symbols": [{"literal":"."}, "location"]},
    {"name": "location$ebnf$1", "symbols": ["location$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "location$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "location", "symbols": ["location$subexpression$1", "location$ebnf$1"]},
    {"name": "expression", "symbols": [{"literal":"("}, "seventhLevel", {"literal":")"}]},
    {"name": "expression", "symbols": ["seventhLevel"]},
    {"name": "expression", "symbols": ["omegaLevel"]},
    {"name": "omegaLevel", "symbols": ["literal"]},
    {"name": "omegaLevel", "symbols": ["location"]},
    {"name": "omegaLevel", "symbols": ["methodCall"]},
    {"name": "firstLevel", "symbols": [{"literal":"-"}, "omegaLevel"]},
    {"name": "firstLevel", "symbols": [{"literal":"!"}, "omegaLevel"]},
    {"name": "firstLevel", "symbols": ["omegaLevel"]},
    {"name": "secondLevel", "symbols": ["secondLevel", "arith_high_op", "firstLevel"]},
    {"name": "secondLevel", "symbols": ["firstLevel"]},
    {"name": "thirdLevel", "symbols": ["thirdLevel", "arith_op", "secondLevel"]},
    {"name": "thirdLevel", "symbols": ["secondLevel"]},
    {"name": "fourthLevel", "symbols": ["fourthLevel", "rel_op", "thirdLevel"]},
    {"name": "fourthLevel", "symbols": ["thirdLevel"]},
    {"name": "fifthLevel", "symbols": ["fifthLevel", "eq_op", "fourthLevel"]},
    {"name": "fifthLevel", "symbols": ["fourthLevel"]},
    {"name": "sixthLevel", "symbols": ["sixthLevel", "and_op", "fifthLevel"]},
    {"name": "sixthLevel", "symbols": ["fifthLevel"]},
    {"name": "seventhLevel", "symbols": ["seventhLevel", "cond_op", "sixthLevel"]},
    {"name": "seventhLevel", "symbols": ["sixthLevel"]},
    {"name": "methodCall$ebnf$1$subexpression$1$ebnf$1", "symbols": []},
    {"name": "methodCall$ebnf$1$subexpression$1$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "arg"]},
    {"name": "methodCall$ebnf$1$subexpression$1$ebnf$1", "symbols": ["methodCall$ebnf$1$subexpression$1$ebnf$1", "methodCall$ebnf$1$subexpression$1$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "methodCall$ebnf$1$subexpression$1", "symbols": ["arg", "methodCall$ebnf$1$subexpression$1$ebnf$1"]},
    {"name": "methodCall$ebnf$1", "symbols": ["methodCall$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "methodCall$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "methodCall", "symbols": [(lexer.has("id") ? {type: "id"} : id), {"literal":"("}, "methodCall$ebnf$1", {"literal":")"}]},
    {"name": "arg", "symbols": ["expression"]},
    {"name": "arith_op", "symbols": [{"literal":"+"}]},
    {"name": "arith_op", "symbols": [{"literal":"-"}]},
    {"name": "arith_high_op", "symbols": [{"literal":"*"}]},
    {"name": "arith_high_op", "symbols": [{"literal":"/"}]},
    {"name": "arith_high_op", "symbols": [{"literal":"%"}]},
    {"name": "rel_op", "symbols": [{"literal":"<"}]},
    {"name": "rel_op", "symbols": [{"literal":">"}]},
    {"name": "rel_op", "symbols": [{"literal":"<="}]},
    {"name": "rel_op", "symbols": [{"literal":">="}]},
    {"name": "eq_op", "symbols": [{"literal":"=="}]},
    {"name": "eq_op", "symbols": [{"literal":"!="}]},
    {"name": "cond_op", "symbols": [{"literal":"||"}]},
    {"name": "and_op", "symbols": [{"literal":"&&"}]},
    {"name": "literal", "symbols": ["int_literal"]},
    {"name": "literal", "symbols": ["char_literal"]},
    {"name": "literal", "symbols": ["bool_literal"]},
    {"name": "int_literal", "symbols": [(lexer.has("num") ? {type: "num"} : num)]},
    {"name": "char_literal", "symbols": [(lexer.has("char") ? {type: "char"} : char)]},
    {"name": "bool_literal", "symbols": [{"literal":"true"}]},
    {"name": "bool_literal", "symbols": [{"literal":"false"}]}
]
  , ParserStart: "program"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
